/**
  ******************************************************************************
  * @file    main.c
  * @author  Auto-generated by STM32CubeIDE
  * @version V1.0
  * @brief   Default main function.
  ******************************************************************************
*/

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include<stdio.h>
#include<stdint.h>

void evoke_interrupt(void)
{
	// Set pointers to STIR and ISER0
	uint32_t *pSTIR=(uint32_t *)0xE000EF00;
	uint32_t *pISER0=(uint32_t *)0xE000E100;

	// Set the ISER0
	*pISER0 |=(1<<3);

	// generate an interrupt for IRQ3
	*pSTIR=(3 & 0x1FF);
}

void change_access(void)
{
	// The function requires to use the control register from the core registers of Cortex M4 hence use of __asm
	// read value of CONTROL reg to R0 -> Change the access level by modification of the 0th bit in CONTROL Reg ->
	__asm volatile("MRS R0,CONTROL"); // MSR is an assembly command for SFRs
	__asm volatile("ORR R0,R0,#0x01");// OR operation of 1 with the value read in R0
	__asm volatile("MSR CONTROL,R0");// write the modified value to CONTROL register
}
int main(void)
{
	printf("In thread mode before interrupt is evoked\n");

	change_access();
	evoke_interrupt();

	printf("In thread mode after interrupt is evoked\n");

	for(;;);
}
// ISR to be executed in handler mode
void RTC_WKUP_IRQHandler(void)
{
	printf("In handler mode: ISR\n");
}
void HardFault_Handler(void)
{
	printf("Hardfault detected \n");
}
