/**
  ******************************************************************************
  * @file    main.c
  * @author  Auto-generated by STM32CubeIDE
  * @version V1.0
  * @brief   Default main function.
  ******************************************************************************
*/

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
#include<stdint.h>
// c marcos for easier readability

#define SRAM_START 0x20000000U
#define SRAM_SIZE (128 * 1024) 						// size is 128k where k=1024 bytes
#define SRAM_END  ((SRAM_START) + (SRAM_SIZE))
#define STACK_START SRAM_END 						// since the stack has a full descending

// divisions between the MSP region and PSP region
#define MSP_START STACK_START
#define MSP_END (STACK_START - 512)
#define PSP_START MSP_END


int add_num(int x,int y,int z,int r)
{
	return x+y+z+r;
}

__attribute__((naked))  sp_to_psp(void) // This attribute allows the compiler to construct the requisite function declaration, while allowing the body of the function to be assembly code. The specified function will not have prologue/epilogue sequences generated by the compiler. Only basic asm statements can safely be included in naked functions (see Basic Asm). While using extended asm or a mixture of basic asm and C code may appear to work, they cannot be depended upon to work reliably and are not supported.pcs
{
	__asm volatile(".equ SRAM_END,(0x20000000+(128*1024))");
	__asm volatile(".equ PSP_START,(SRAM_END - 512)");
	// Initialise PSP
	__asm volatile("LDR R0,=PSP_START"::); // load R0 with value of PSP_START
	__asm volatile("MSR PSP,R0"::);		  //  Load PSP with value of R0

	__asm volatile("MOV R0,#0x02"::);	 // MOV is used for 16 bit commands; here we set the 1st bit for SPSEL bit set
	__asm volatile("MSR CONTROL,R0"::); //  Load value of 0x02 in CONTROL reg to set SPSEL bit to select stack

	__asm volatile("BX LR");  			// return to the main function - indirect branching
}

void interrupt_evoke(void)
{
	__asm volatile("SVC #0x03");
}
int main(void)
{
	sp_to_psp();
	int val;
	val=add_num(3,4,6,9);
	printf("The result is %d",val);
	interrupt_evoke();
	for(;;);
}
void SVC_Handler(void)
{
	printf("SVC Handler\n");
}
